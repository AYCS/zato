.. highlight:: python
   :linenothreshold: 0

Writing a service
=================

From a programmer's point of view, a service is a Python class that subclasses
zato.server.Service and implements a handle(self) method.

Below is the simplest possible Zato service meant to illustrate the point of how
little coding is needed to write services. Granted, it doesn't do much useful,
but still can be :doc:`hot-deployed <TODO>` and while it's not possible to
:doc:`invoke <TODO>`
it
:doc:`through <TODO>`
:doc:`channels <TODO>`,
it's still a valid service.


::

   from zato.server.service import Service
   
   class MyService(Service):
       def handle(self):
           pass
           
Programming conventions
-----------------------

* Services are developed in `Python 2.7.x <http://docs.python.org/2.7/>`_. No
  other Python versions can be used although adding support for Python 3.x is planned.

* You can't use the name 'zato', case-insensitively, anywhere. Any such names
  are reserved and can't be used, for instance 'zato.sample', 'my:zato:data',
  'X-ZATO-SERVER' and 'ZatoReceiver' are all invalid.
  
  This applies to any Zato object you will use - services, connection names,
  channel names, any other.
  
* All input and output is always in UTF-8. Zato doesn't use nor support any other 
  encoding. Each request and response must always be in UTF-8.

* You are strongly encouraged to use the following header in each source code
  file you will keep services in. In fact, if you stumble upon any issues you
  and need support you will be first asked that this header be added before any
  other advice can be given. Don't forget to set your code editor to write out
  files in UTF-8 too.
  
  This serves a couple of purposes:
  
  * Makes sure you actually use UTF-8 in your code
  * Lets you get prepared for Python 3.x
  * Ensures you use the same Python features :doc:`Zato's own services </public-api/intro>` use

  ::  
  
    # -*- coding: utf-8 -*-
  
    from __future__ import absolute_import, division, print_function, unicode_literals
    
* Each service invocation creates a new instance of the class the service is 
  represented as.
    
* Don't keep any state around if you want to use the :doc:`hot-deployment` feature.
  Don't assign any values to classes the services are implemented in. Don't modify
  any module-global data. Use :doc:`Redis <TODO>` if you need to store data between
  invocations of a service. Otherwise it will still be possible to deploy a service
  but not without restarting a server.
  
* Don't start your own threads. Given Zato's architecture, there shouldn't really
  be any need for threads but if your use-case calls for it, please let the
  project know about it and explain why you need threads.
    
What a service can do
---------------------

Typically, a service will receive some input and produce an output. Both steps
are optional but usually at least one of them will be performed.

You can use 
:doc:`Simple IO (SIO)<./sio>`,
:doc:`JSON <./json>`,
:doc:`XML <./xml>`
or 
:doc:`any other data type <./other-formats>`
in your services.

Depending on the choices you make, it will be usually possible to make the very
same service, with no changes to the code, available across multiple channels
- 
:doc:`AMQP <TODO>`
:doc:`JMS WebSphere MQ <TODO>`
:doc:`Plain HTTP <TODO>`
:doc:`SOAP <TODO>`
and 
:doc:`Zero MQ <TODO>`


You can store data in 
Redis,
SQL databases
and specify your services be
periodically invoked through the scheduler.

A service can
:doc:`invoke other services <./invoking-services>`
as well as access resources outside a Zato environment.
The latter ones include
:doc:`AMQP <TODO>`,
:doc:`JMS WebSphere MQ <TODO>`,
:doc:`Plain HTTP <TODO>`,
:doc:`SOAP <TODO>`,
:doc:`Zero MQ <TODO>`
and 
:doc:`FTP <TODO>`.


Service API
-----------

This chapter will introduce the service API - a set of attributes and methods
a service can make use of during processing of the messages.

First, save the following code in service_api.py, :doc:`hot-deploy <TODO>` it - this will be
the servce that will be modified throughout the rest of the text. A new plain HTTP channel
should also be created so that the service can be easily accessed through `curl <http://curl.haxx.se>`_.

::

   from zato.server.service import Service
   
   class MyService(Service):
       def handle(self):
           pass

.. image:: /gfx/progguide/service-api-channel1.png
   :align: center

Attributes
~~~~~~~~~~

broker_client
`````````````

Services can publish messages on a :doc:`Redis </architecture/redis>` broker. 
How to use a broker client is explained in a :ref:`separate chapter <progguide-write-service-broker-client>`.

channel
```````

Type of the channel (not its name) a service has been invoked through. 
Can be one of:

* 'amqp'
* 'http-soap'
* 'jms-wmq'
* 'scheduler'
* 'zmq'

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          self.logger.info('channel:[{}]'.format(self.channel))

::

  $ curl localhost:17010/service-api.my-service
  
::

  INFO - channel:[http-soap]
  

cid
```

A correlation ID (CID) of this request. Each request is assigned a CID
which is :doc:`(TODO update public API) <TODO>` 128 bits of random data, encoded as a string.
The string is prefixed with the letter 'K' to ensure that it always start with a character. There
is nothing special about the letter 'K', it just seemed a character that shouldn't
be easy to confuse with any other in the ASCII range.

CID has always 40 characters.

.. warning ::

  You must not use CIDs for any cryptographical purposes. There is no guarantee
  that a CID will be suitable for any particular crypto operation. CIDs should
  only be used to tell one request from another. Use
  `UUID4 <http://docs.python.org/2.7/library/uuid.html>`_ or a similar data
  type if you need truly random data.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          self.logger.info('cid:[{}]'.format(self.cid))

::

  $ curl localhost:17010/service-api.my-service
  
::

  INFO - cid:[K280592090634247650299684980809341216327]
  
  
data_format
```````````

Each channel can optionally define that the data flowing in will be in
a particular data format. It can be one of:

* None
* 'json'
* 'xml'

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          self.logger.info('data_format:[{}]'.format(self.data_format))

::

  $ curl localhost:17010/service-api.my-service
  
::

  INFO - data_format:[None]
  
environ
```````

A dictionary of user-specific data that can be used for passing information
between :doc:`service hooks <TODO>`. The service can store information in a
hook method and consult it in another one using the environ dictionary.

Zato will never use environ for its own purposes.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def before_handle(self):
          self.environ['seen_before_invoke'] = True
      
      def handle(self):
          self.environ['seen_handle'] = True
          
      def after_handle(self):
          for name in('seen_before_invoke', 'seen_handle'):
              self.logger.info('{}:[{}]'.format(name, self.environ[name]))

::

  $ curl localhost:17010/service-api.my-service
  
::

  INFO - seen_before_invoke:[True]
  INFO - seen_handle:[True]


.. _progguide-write-service-handle_return_time:

handle_return_time
``````````````````

A `datetime.datetime <http://docs.python.org/2.7/library/datetime.html#datetime-objects>`_
objects representing the time a service's :ref:`handle <TODO>` method returned.
Always in UTC.

Note that it will be available as a non-None value only in the finalize_handle service hook.

:ref:`invocation_time <progguide-write-service-invocation_time>` and
handle_return_time are used to compute the values of 
:ref:`processing_time <progguide-write-service-processing_time>`
and
:ref:`processing_time_raw <progguide-write-service-processing_time_raw>`.

.. _progguide-write-service-impl_name:

impl_name
`````````

Name of the module and class actually implementing a given service. Contrast
with :ref:`name <progguide-write-service-name>`.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          self.logger.info('impl_name:[{}]'.format(self.impl_name))

::

  $ curl localhost:17010/service-api.my-service
  
::

  INFO - impl_name:[service_api.MyService]

.. _progguide-write-service-invocation_time:

invocation_time
```````````````

A `datetime.datetime <http://docs.python.org/2.7/library/datetime.html#datetime-objects>`_
object representing the time a service has been invoked. Always in UTC.

invocation_time and
:ref:`handle_return_time <progguide-write-service-handle_return_time>` are used to compute the values of 
:ref:`processing_time <progguide-write-service-processing_time>`
and
:ref:`processing_time_raw <progguide-write-service-processing_time_raw>`.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          self.logger.info('invocation_time:[{}]'.format(self.invocation_time))

::

  $ curl localhost:17010/service-api.my-service
  
::

  INFO - invocation_time:[2013-02-17 17:47:01.045913]


job_type
````````

If a service has been :doc:`invoked through a scheduler's job <TODO>`, type of the job
it was. None if the scheduler wasn't used. Can be one of:

* None
* 'one_time'
* 'interval_based'
* 'cron_style'

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          self.logger.info('job_type:[{}]'.format(self.job_type))

::

  $ curl localhost:17010/service-api.my-service
  
::

  INFO - job_type:[None]
  
kvdb
````

An object which lets one use :doc:`Redis, Zato's key/value database (KVDB) <TODO>`.
The underlying `redis-py connection <https://github.com/andymccurdy/redis-py>`_
is available as self.kvdb.conn.

::

  from zato.common import KVDB
  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          key = '{}{}'.format(KVDB.SERVICE_USAGE, self.name)
          usage = self.kvdb.conn.get(key)
          self.logger.info('{} was invoked {} time(s)'.format(self.name, usage))

::

  $ curl localhost:17010/service-api.my-service
  
::

  INFO - service-api.my-service was invoked 16 time(s)

logger
``````

A logger, instance of zato.server.log.ZatoLogger, used for writing messages out to server logs.
This is a thin wrapper around `Python's logging.Logger <http://docs.python.org/2.7/library/logging.html>`_
which lets one use a 'cid' argument in addition to what is ordinarily available
when using a standard logger. This allows to use a 'cid' parameter in server logs.

Observe how log output changes depending on the format used:

::

  %(asctime)s - %(cid)s - %(message)s

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          self.logger.info('Hello!', cid=self.cid)

::

  $ curl localhost:17010/service-api.my-service
  
::

  2013-02-17 19:48:33,585 - K300817487686039172650072756834592513215 - Hello!
  

.. _progguide-write-service-name:
  
name
````

Name of the service under which it will be possible to :ref:`invoke it <progguide-write-service-invoke>` and point to it
in the web admin. Contrast with :ref:`impl_name <progguide-write-service-impl_name>`.

Visit :ref:`get_name <progguide-write-service-request-get_name>` for a way to override it.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          self.logger.info('name:[{}]'.format(self.name))

::

  $ curl localhost:17010/service-api.my-service
  
::

  INFO - name:[service-api.my-service]
  
odb
```

An object through which one can access 
:doc:`Zato's Operational Database (ODB) </architecture/sql-odb>`.
An `SQLAlchemy <http://sqlalchemy.org>`_ session object,
used to issue queries, is available as .session() - note that it always needs to be 
closed manually hence the use of the
`closing <http://docs.python.org/2.7/library/contextlib.html#contextlib.closing>`_
context manager in the example below.

::

  # stdlib
  from contextlib import closing
  
  # Zato 
  from zato.common.odb.model import Cluster
  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          with closing(self.odb.session()) as session:
              for item in session.query(Cluster).all():
                  self.logger.info(item.name)

::

  $ curl localhost:17010/service-api.my-service
  
.. code-block:: text

  INFO - quickstart-351218
  INFO - quickstart-807391
  INFO - quickstart-984115
  INFO - quickstart-136892
  INFO - quickstart-758758
  
outgoing
````````

Lets one invoke external
:doc:`FTP <TODO>`,
:doc:`AMQP <TODO>`,
:doc:`ZeroMQ <TODO>`,
:doc:`JMS WebSphere MQ <TODO>`,
:doc:`SQL <TODO>`,
:doc:`Plain HTTP <TODO>`
and 
:doc:`SOAP <TODO>`
resources. Consult the documentation of each one for more information.

.. _progguide-write-service-processing_time:

processing_time
```````````````

Time it took for the service to complete its operation, in milliseconds. Compare with 
:ref:`processing_time_raw <progguide-write-service-processing_time_raw>`.

Note that it will be available as a non-None value only in the 
:doc:`finalize_handle service hook <TODO>`.

processing_time will be equal to 0 if it took less than 1 ms.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          pass
      
      def finalize_handle(self):
          self.logger.info('Processing took {} ms'.format(self.processing_time))

::

  $ curl localhost:17010/service-api.my-service
  
.. code-block:: text

  INFO - Processing took 0 ms
  
.. _progguide-write-service-processing_time_raw:
  
processing_time_raw
```````````````````
A datetime.timedelta objects representing the time spent in a service,
with microseconds precision. 
Compare with :ref:`processing_time <progguide-write-service-processing_time>`.

Note that it will be available as a non-None value only in the 
:doc:`finalize_handle service hook <TODO>`.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          pass
      
      def finalize_handle(self):
          self.logger.info('Processing took {}'.format(self.processing_time_raw))

::

  $ curl localhost:17010/service-api.my-service
  
.. code-block:: text

  INFO - Processing took 0:00:00.000077
  
request
```````

:ref:`request <progguide-write-service-request-object>`
and
:ref:`response <progguide-write-service-response-object>`
attributes are discussed in their
own sections.

response
````````
:ref:`request <progguide-write-service-request-object>`
and
:ref:`response <progguide-write-service-response-object>`
attributes are discussed in their
own sections.

slow_threshold
``````````````
Response time threshold, in milliseconds, after exceeding of which a service
invocation will be considered :doc:`a slow one <TODO>`. Top 100 slow invocations
of a service are stored for a later inspection.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          self.logger.info('My threshold is {} ms'.format(self.slow_threshold))

::

  $ curl localhost:17010/service-api.my-service
  
.. code-block:: text

  INFO - My threshold is 99999 ms
  
usage
`````
How many times the service has run, including the current invocation.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          self.logger.info('My usage is {}'.format(self.usage))

::

  $ curl localhost:17010/service-api.my-service
  
.. code-block:: text

  INFO - My usage is 38
  
wsgi_environ
````````````
Zato's HTTP server is a 
`WSGI <https://en.wikipedia.org/wiki/Web_Server_Gateway_Interface>`_
one. If a service has been invoked through HTTP, wsgi_environ will be a dictionary of WSGI data.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          for key, name in sorted(self.wsgi_environ.items()):
              self.logger.info('{}:{}'.format(key, name))

::

  $ curl localhost:17010/service-api.my-service
  
.. code-block:: text

  INFO - HTTP_ACCEPT:*/*
  INFO - HTTP_HOST:localhost:17010
  INFO - HTTP_USER_AGENT:curl/7.22.0 (x86_64-pc-linux-gnu)
  INFO - PATH_INFO:/service-api.my-service
  INFO - QUERY_STRING:
  INFO - RAW_URI:/service-api.my-service
  INFO - REMOTE_ADDR:127.0.0.1
  INFO - REMOTE_PORT:34707
  INFO - REQUEST_METHOD:GET
  INFO - SCRIPT_NAME:
  INFO - SERVER_NAME:localhost
  INFO - SERVER_PORT:17010
  INFO - SERVER_PROTOCOL:HTTP/1.1
  INFO - SERVER_SOFTWARE:gunicorn/0.16.1
  INFO - gunicorn.socket:<socket fileno=12 sock=127.0.0.1:17010 peer=127.0.0.1:34707>
  INFO - wsgi.errors:<open file '<stderr>', mode 'w' at 0x7f6bd98b6270>
  INFO - wsgi.file_wrapper:gunicorn.http.wsgi.FileWrapper
  INFO - wsgi.input:<gunicorn.http.body.Body object at 0x5711910>
  INFO - wsgi.multiprocess:True
  INFO - wsgi.multithread:False
  INFO - wsgi.run_once:False
  INFO - wsgi.url_scheme:http
  INFO - wsgi.version:(1, 0)
  INFO - zato.http.response.headers:{}
  
You can use the dictionary under zato.http.response.headers to return custom HTTP headers
to the calling application. Visit :doc:`here <TODO>` for information how to influence other
parts of an HTTP response.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          self.wsgi_environ['zato.http.response.headers']['X-My-Header'] = 'foobar'

.. code-block:: text
  :emphasize-lines: 15

  $ curl -v localhost:17010/service-api.my-service
  * About to connect() to localhost port 17010 (#0)
  *   Trying 127.0.0.1... connected
  > GET /service-api.my-service HTTP/1.1
  > User-Agent: curl/7.22.0 (x86_64-pc-linux-gnu)
  > Host: localhost:17010
  > Accept: */*
  > 
  < HTTP/1.1 200 OK
  < Server: gunicorn/0.16.1
  < Date: Sun, 17 Feb 2013 22:48:40 GMT
  < Connection: keep-alive
  < Transfer-Encoding: chunked
  < Content-Type: text/plain
  < X-My-Header: foobar
  < 
  * Connection #0 to host localhost left intact
  * Closing connection #0
  $

Methods
~~~~~~~

after_add_to_store
``````````````````

.. py:staticmethod:: after_add_to_store()

Static method executed right after a service class has been added to the
service store. Explained further in the :doc:`chapter on service hooks <TODO>`.

after_cron_style_job
````````````````````

.. py:method:: after_cron_style_job()

Method executed right after a service has been invoked through a cron-style job.
Explained further in the :doc:`chapter on service hooks <TODO>`.

after_handle
````````````

.. py:method:: after_handle()

Method executed right after a service's :ref:`handle progguide-write-service-handle>`
method has returned. Explained further in the :doc:`chapter on service hooks <TODO>`.

after_interval_based_job
````````````````````````

.. py:method:: after_interval_based_job()

Method executed right after a service has been invoked through an interval-based job.
Explained further in the :doc:`chapter on service hooks <TODO>`.

after_job
`````````

.. py:method:: after_job()

Method executed right after a service has been invoked through a scheduler's
job, regardless of the latter's type.
Explained further in the :doc:`chapter on service hooks <TODO>`.

after_one_time_job
``````````````````

.. py:method:: after_one_time_job()

Method executed right after a service has been invoked through a one-time job.
Explained further in the :doc:`chapter on service hooks <TODO>`.

before_add_to_store
```````````````````

.. py:staticmethod:: before_add_to_store()

Static method executed right after a service class is added to the service store.
The service won't be deployed unless the method returns True.
Explained further in the :doc:`chapter on service hooks <TODO>`.

before_cron_style_job
`````````````````````

.. py:method:: before_cron_style_job()

Method executed right before a service is invoked through a cron-style job.
Explained further in the :doc:`chapter on service hooks <TODO>`.

before_handle
`````````````

.. py:method:: before_handle()

Method executed right before a service's :ref:`handle progguide-write-service-handle>`
is run. Explained further in the :doc:`chapter on service hooks <TODO>`.

before_interval_based_job
`````````````````````````

.. py:method:: before_interval_based_job()

Method executed right before a service is invoked through an interval-based job.
Explained further in the :doc:`chapter on service hooks <TODO>`.

before_job
``````````

.. py:method:: before_job()

Method executed right before a service is invoked through a scheduler's job,
regardless of the job's type.
Explained further in the :doc:`chapter on service hooks <TODO>`.

before_one_time_job
```````````````````

.. py:method:: before_one_time_job()

Method executed right before a service is invoked through a one-time job.
Explained further in the :doc:`chapter on service hooks <TODO>`.

finalize_handle
```````````````

.. py:method:: finalize_handle()

Method executed after :ref:`handle progguide-write-service-handle>` and other service
hooks have completed. Explained further in the :doc:`chapter on service hooks <TODO>`.

.. _progguide-write-service-request-get_name:

get_name
````````

.. py:staticmethod:: get_name()

A static method that should be implemented to return
:ref:`service names <progguide-write-service-name>` other than what Zato
automatically generates.

::

  from zato.server.service import Service
  
  class MyService(Service):
      def handle(self):
          self.logger.info('My name is {}'.format(self.name))
          
      @staticmethod
      def get_name():
          return 'Something Else'

::

  $ curl localhost:17010/service-api.my-service
  
::

  INFO - My name is Something Else
  
handle
``````

.. py:method:: handle()

The only method a service must implement. The central place where most of the
message processing will take place. Each time a channel accepts a message,
a new instance of the service class will be created and its handle method will
be called. 

There is a :doc:`chapter with usage examples <TODO>` to give you an idea what a service's
handle method can do.

.. _progguide-write-service-invoke:

invoke
``````
.. py:method:: invoke(name, payload[, data_format=None, transport=None, serialize=False, as_bunch=False])

  Invokes a service by its :ref:`name <progguide-write-service-name>`. The service
  is invoked in the same operating system's process and thread the current service
  is in. This is simply a standard invocation of another method so any exceptions
  raised in the service being invoked will propagate to the calling one.
  
  From the point of view of the service which is invoked, there is no way to
  discern that it's not being invoked through a regular channel created in the
  :doc:`web admin <TODO>` or via :doc:`Zato's public API </public-api/intro>`.
  
  :param name: name of the service to invoke
  :type name: string
  
  :param payload: request data to invoke a service with
  
  :rtype: payload the service being invoked produced

.. _progguide-write-service-broker-client:

Broker client
-------------

.. _progguide-write-service-request-object:

Request object
--------------

.. _progguide-write-service-response-object:

Response object
---------------
